---
title: CLOS åŸºæœ¬ä»‹ç»
---


CLOS æ˜¯ "Common Lisp Object System" çš„ç¼©å†™ï¼Œæ˜¯æ‰€æœ‰è¯­è¨€ä¸­æœ€å¼ºå¤§çš„å¯¹è±¡ç³»ç»Ÿä¹‹ä¸€ã€‚

æœ‰ä»¥ä¸‹çš„ç‰¹æ€§ï¼š

* **åŠ¨æ€ï¼ˆdynamicï¼‰**ï¼Œåœ¨ Lisp çš„ REPLï¼ˆå³è§£é‡Šå™¨ï¼‰ä¸­å†™èµ·æ¥å¾ˆèˆ’æœã€‚æ¯”å¦‚è¯´ï¼Œå½“ä¸€ä¸ªç±»çš„å®šä¹‰æ”¹å˜äº†ï¼Œä¹‹å‰ç±»æ‰€åˆ›å»ºçš„å¯¹è±¡ä¹Ÿä¼šéšä¹‹æ›´æ–°ï¼Œè¿™æ ·æ“ä½œå¯¹è±¡ä¹Ÿæ›´ç›´è§‚æ˜äº†;
* **å¤šæ´¾ç”Ÿï¼ˆmultipleï¼‰** ä»¥åŠ **å¤šç»§æ‰¿ï¼ˆmultiple inheritanceï¼‰**ï¼›
* **å†…çœï¼ˆintrospectionï¼‰** 
* **å…ƒå¯¹è±¡æ¥å£ï¼ˆmeta-object protocolï¼‰**ï¼Œæä¾› CLOS æ ‡å‡†æ¥å£ï¼Œå¯ä»¥ç”¨æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ç³»ç»Ÿã€‚

CLOS æœ€åˆæ˜¯åœ¨ 1984 å¹´ Steele çš„ "Common Lisp, the Language" ç¬¬ä¸€ç‰ˆä¸­å‡ºç°ï¼Œåå¹´åè¢«æ­£å¼å®šä¹‰ä¸º ANSI æ ‡å‡†ã€‚

æœ¬ç« æ—¨åœ¨è®²è§£ CLOS çš„ä½¿ç”¨ï¼Œä½†åªæ˜¯ç®€å•çš„ä»‹ç»äº†ä¸‹ MOPã€‚

æƒ³è¦æ·±å…¥äº†è§£çš„è¯ï¼Œæ¨èä¸‹é¢ä¸¤æœ¬ä¹¦ï¼š

- [Object-Oriented Programming in Common Lisp: a Programmer's Guide to CLOS](http://www.communitypicks.com/r/lisp/s/17592186046723-object-oriented-programming-in-common-lisp-a-programmer), by Sonya Keene,
- [the Art of the Metaobject Protocol](http://www.communitypicks.com/r/lisp/s/17592186045709-the-art-of-the-metaobject-protocol), by Gregor Kiczales, Jim des RiviÃ¨res et al.

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥å‚è§ä¸‹é¢çš„é“¾æ¥ã€‚

- the introduction in [Practical Common Lisp](http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html) (online), by Peter Seibel.
-  [Common Lisp, the Language](https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node260.html#SECTION003200000000000000000)
- and for reference, the complete [CLOS-MOP specifications](https://clos-mop.hexstreamsoft.com/).


#  ç±»å’Œå®ä¾‹

## åº

é¦–å…ˆï¼Œç”¨ä¸ªå®Œæ•´çš„ä¾‹å­æ¥è®²è§£ä¸‹ç±»çš„å®šä¹‰ï¼Œå¯¹è±¡çš„åˆ›å»ºï¼Œå±æ€§çš„è®¿é—®ï¼Œæ–¹æ³•çš„æ„é€ ä»¥åŠç»§æ‰¿å…³ç³»ã€‚

~~~lisp
(defclass person ()
  ((name
    :initarg :name
    :accessor name)
   (lisper
    :initform nil
    :accessor lisper)))

;; => #<STANDARD-CLASS PERSON>

(defvar p1 (make-instance 'person :name "me" ))
;;                                 ^^^^ initarg
;; => #<PERSON {1006234593}>

(name p1)
;;^^^ accessor
;; => "me"

(lisper p1)
;; => nil
;;    ^^ initform (slot unbound by default)

(setf (lisper p1) t)


(defclass child (person)
  ())

(defclass child (person)
  ((can-walk-p
     :accessor can-walk-p
     :initform t)))
;; #<STANDARD-CLASS CHILD>

(can-walk-p (make-instance 'child))
;; T
~~~

## å®šä¹‰ç±» (defclass)

`defclass` æ˜¯ä¸ªå®ï¼Œåœ¨ CLOS ä¸­å®šä¹‰æ–°çš„æ•°æ®ç±»å‹ã€‚

~~~lisp
(defclass person ()
  ((name
    :initarg :name
    :accessor name)
   (lisper
    :initform nil
    :accessor lisper)))
~~~

ä»¥ä¸Šä»£ç åˆ›å»ºäº†ä¸€ä¸ª `person` ç±»ï¼Œæœ‰ä¸¤ä¸ªå±æ€§ï¼š`name` å’Œ `lisper`.

~~~lisp
(class-of p1)
#<STANDARD-CLASS PERSON>

(type-of p1)
PERSON
~~~

ä»¥ä¸‹æ˜¯ `defclass` çš„æ ‡å‡†æ ¼å¼:

```
(defclass <class-name> (list of super classes)
  ((slot-1
     :slot-option slot-argument)
   (slot-2, etc))
  (:optional-class-option
   :another-optional-class-option))
```

ä¸Šé¢çš„ `person` ç±»æ²¡æœ‰ç»§æ‰¿è‡ªå…¶ä»–çš„ç±»ï¼ˆçˆ¶ç±»çš„åå­—ä¼šå®šä¹‰åœ¨ç±»åå­—åé¢çš„æ‹¬å·ä¸­ï¼‰ã€‚å½“ç„¶ï¼Œ`person` é»˜è®¤æ˜¯ç»§æ‰¿è‡ª `t` ç±»å’Œ `standard-object`ï¼Œä»¥ä¸ºåœ¨ CLOS ä¸­ï¼Œæ‰€ä»¥çš„ç±»éƒ½ç»§æ‰¿è‡ªè¿™ä¸¤ä¸ªç±»ã€‚ä¸‹é¢çš„ç»§æ‰¿çš„ç« èŠ‚ä¼šæåˆ°ã€‚

å¯ä»¥å®šä¹‰ä¸€ä¸ªç®€å•çš„æ— å±æ€§çš„ `point` ç±»

~~~lisp
(defclass point ()
  (x y z))
~~~

æˆ–è€…å†ç®€å•ç‚¹ï¼Œè¿å±æ€§åéƒ½ä¸å†™ï¼š`(defclass point () ())`ã€‚

## åˆ›å»ºå¯¹è±¡ (make-instance)

åˆ›å»ºå¯¹è±¡æ˜¯è¦ä½¿ç”¨ `make-instance` ç±»:

~~~lisp
(defvar p1 (make-instance 'person :name "me" ))
~~~

ä¸€èˆ¬æ¥è¯´ï¼Œæœ€å¥½æ˜¯åœ¨åˆ›å»ºä¸ªæ„é€ å‡½æ•°ï¼š

~~~lisp
(defun make-person (name &key lisper)
  (make-instance 'person :name name :lisper lisper))
~~~

æœ‰äº†æ„é€ å‡½æ•°ï¼Œå°±å¯ä»¥æ›´å¥½çš„æ§åˆ¶ä¸€äº›ç‰¹å®šçš„å‚æ•°ï¼ŒåŒæ—¶åœ¨ä½¿ç”¨åŒ…æ—¶ï¼Œå°±å¯ä»¥ä¸ç”¨å»çœ‹ç±»çš„åˆ›å»ºï¼Œç›´æ¥è°ƒç”¨æ„é€ å‡½æ•°å°±å¥½ã€‚

## å±æ€§ (Slots)

###  slot-value

`slot-value` å¯ä»¥é€šè¿‡ `(slot-value <object> <slot-name>)` çš„æ ¼å¼éšæ—¶è®¿é—®å¯¹è±¡çš„å±æ€§ï¼Œ

å›åˆ°å®šä¹‰çš„ `point` ç±»ä¸Šï¼Œè¿™ä¸ªç±»æ²¡æœ‰å®šä¹‰å±æ€§çš„è®¿é—®æ¥å£ã€‚

```lisp
(defvar pt (make-instance 'point))

(inspect pt)
The object is a STANDARD-OBJECT of type POINT.
0. X: "unbound"
1. Y: "unbound"
2. Z: "unbound"
```

ä»¥ä¸Šè™½ç„¶åˆ›å»ºäº†ä¸€ä¸ª `POINT` å¯¹è±¡ï¼Œä½†æ˜¯å…¶å±æ€§éƒ½æ²¡æœ‰ç»‘å®šé»˜è®¤å€¼ï¼Œè®¿é—®å…¶å±æ€§æ—¶å°±ä¼šæŠ¥ `UNBOUND-SLOT` å¼‚å¸¸ï¼š

~~~lisp
(slot-value pt 'x) ;; => condition: the slot is unbound
~~~

`slot-value` å¯ä»¥ä½¿ç”¨ `setf` æ¥è¿›è¡Œè®¾ç½®:

~~~lisp
(setf (slot-value pt 'x) 1)
(slot-value pt 'x) ;; => 1
~~~

### åˆå§‹åŒ–ã€é»˜è®¤å€¼ (initarg, initform)

- `:initarg :foo`ï¼šä½¿ç”¨ `make-instance` åˆ›å»ºæ˜¯é€šè¿‡å±æ€§åï¼ˆslotsï¼‰æ¥ç»™å±æ€§èµ‹å€¼çš„ï¼Œå…¶ä¸­åé¢çš„ `:foo` å°±å±æ€§åã€‚

~~~lisp
(make-instance 'person :name "me")
~~~

åœ¨æ¬¡å¼ºè°ƒï¼Œå±æ€§é»˜è®¤æ˜¯ä¸ä¼šç»‘å®šå±æ€§åï¼ˆslotsï¼‰çš„ã€‚

- `:initform <val>`ï¼šå½“æ²¡æœ‰å®šä¹‰å…¶å±æ€§åï¼ˆinitargï¼‰æ—¶ï¼Œ`:initform` åé¢çš„å€¼å°±æ˜¯è¯¥å±æ€§çš„é»˜è®¤å€¼ã€‚åœ¨ `defclass` çš„è¯æ³•ä½œç”¨åŸŸä¸­ï¼Œåœ¨éœ€è¦æ—¶ï¼Œè¿™ä¸ªè¡¨è¾¾å¼å°±ä¼šè¿è¡Œã€‚

ä¸€ä¸ªå¯ä»¥æ¸…æ¥šçš„çŸ¥é“éœ€è¦ç»™å±æ€§èµ‹å€¼çš„æŠ€å·§ï¼š

~~~lisp
(defclass foo ()
    ((a
      :initarg :a
      :initform (error "you didn't supply an initial value for slot a"))))
;; #<STANDARD-CLASS FOO>

(make-instance 'foo) ;; => enters the debugger.
~~~


### Getters and setters (accessor, reader, writer)

- `:accessor foo`ï¼šæ—¢æ˜¯ **getter** ä¹Ÿæ˜¯ **setter**ã€‚`:accessor` åé¢æ¥çš„å‚æ•°å°†ä¼šæˆä¸º **é€šç”¨å‡½æ•°**.

~~~lisp
(name p1) ;; => "me"

(type-of #'name)
STANDARD-GENERIC-FUNCTION
~~~

- `:reader` and `:writer`ï¼šè¿™æ‰æ˜¯ä½ æƒ³è¦çš„ï¼Œåªæœ‰ `:writer` å¯ä»¥ä½¿ç”¨ `setf` è¿›è¡Œèµ‹å€¼.

å¦‚æœä¸ä½¿ç”¨ä»¥ä¸Šè¿™äº›çš„è¯ï¼Œ `slot-value` ä¹ŸåŒæ ·å¯ä»¥ä¿®æ”¹å±æ€§çš„å€¼.

åŒä¸€å±æ€§å¯ä»¥æœ‰å¤šä¸ª `:accessor`ã€ `:reader`ã€ `:initarg`.


ä¸‹é¢å°†ä»‹ç»ä¸¤ä¸ªå®ï¼Œè¿™ä¸¤ä¸ªå®åœ¨è¾“å‡ºç±»çš„å±æ€§å€¼æ—¶ä¼šå¾ˆæ–¹ä¾¿ï¼š

1- `with-slots`ï¼Œå¯ä»¥åŒæ—¶è®¿é—®å¤šä¸ªå±æ€§å€¼ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸ªåŒ…å«äº†å±æ€§åçš„åˆ—è¡¨ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸ªå¯¹è±¡å®ä¾‹ï¼Œä¹‹åçš„æ˜¯ç”± `progn` æ‰€åŒ…å«çš„ä¸€äº›è¯­å¥ï¼Œæˆ–è€…è¯´æ˜¯å…¶ä¸»ä½“éƒ¨åˆ†ï¼Œåœ¨ä¸»ä½“çš„è¯æ³•ä½œç”¨åŸŸä¸­ï¼Œè°ƒç”¨ç¬¬ä¸€ä¸ªå‚æ•°åˆ—è¡¨ä¸­çš„å˜é‡ç±»ä¼¼äºä½¿ç”¨ `slot-value` å»è®¿é—®å®ä¾‹çš„å±æ€§å€¼ã€‚


~~~lisp
(with-slots (name lisper)
    c1
  (format t "got ~a, ~a~&" name lisper))
~~~

~~~lisp
(with-slots ((n name)
             (l lisper))
    c1
  (format t "got ~a, ~a~&" n l))
~~~

2- `with-accessors`ï¼šäº `with-slots` ç±»ä¼¼ï¼Œåªä¸è¿‡ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è®¿é—®å±æ€§çš„å‡½æ•°ï¼ˆaccessor functionsï¼‰

~~~lisp
(with-accessors ((name        name)
                  ^^variable  ^^accessor
                 (lisper lisper))
            p1
          (format t "name: ~a, lisper: ~a" name lisper))
~~~

### ç±» VS å®ä¾‹å±æ€§

`:allocation`ï¼šå®šä¹‰å±æ€§æ˜¯ *æœ¬åœ°çš„* è¿˜æ˜¯ *å…±äº«çš„*ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„ç§æœ‰å±æ€§å’Œå…¬æœ‰å±æ€§ã€‚

* å±æ€§é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œå°±æ˜¯è¯´æ¯ä¸ªå®ä¾‹çš„å±æ€§å€¼éƒ½ä¸åŒã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œ`:allocation` ç­‰ä»·äº `:instance`ï¼›

* å…¬æœ‰å±æ€§å¯ä»¥è¢«è¯¥ç±»çš„æ‰€æœ‰å€¼è®¿é—®ï¼Œä¸”ä¿æŒä¸€è‡´ï¼Œå®šä¹‰æ–¹æ³•ä¸ºï¼š`:allocation :class`ã€‚

ä¸‹é¢æ˜¯ä¸ªå…¬æœ‰å±æ€§çš„ä¾‹å­ï¼š

~~~lisp
(defclass person ()
  ((name :initarg :name :accessor name)
   (species
      :initform 'homo-sapiens
      :accessor species
      :allocation :class)))

;; Note that the slot "lisper" was removed in existing instances.
(inspect p1)
;; The object is a STANDARD-OBJECT of type PERSON.
;; 0. NAME: "me"
;; 1. SPECIES: HOMO-SAPIENS
;; > q

(defvar p2 (make-instance 'person))

(species p1)
(species p2)
;; HOMO-SAPIENS

(setf (species p2) 'homo-numericus)
;; HOMO-NUMERICUS

(species p1)
;; HOMO-NUMERICUS

(species (make-instance 'person))
;; HOMO-NUMERICUS

(let ((temp (make-instance 'person)))
    (setf (species temp) 'homo-lisper))
;; HOMO-LISPER
(species (make-instance 'person))
;; HOMO-LISPER
~~~

### å±æ€§æ–‡æ¡£

æ¯ä¸ªå±æ€§éƒ½æœ‰ä¸ª `:documentation` çš„å‚æ•°

### å±æ€§çš„ç±»å‹

å±æ€§ç±»å‹ä½¿ç”¨ `:type` æ¥å®šä¹‰ã€‚å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦ CLOSï¼Œå»ºè®®ä½ è·³è¿‡è¿™èŠ‚ï¼Œç„¶åè‡ªå·±å»æ„é€ ç±»å‹æ£€æŸ¥çš„ç±»ã€‚ 

äº‹å®ä¸Šï¼Œå±æ€§çš„ç±»å‹ä¼šä¸ä¼šæ£€æŸ¥å¹¶æ²¡æœ‰å®šä¹‰å‡ºæ¥ã€‚è¯¦è§ [Hyperspec](http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass).

åªæœ‰å°‘éƒ¨åˆ†è§£é‡Šå™¨ä¼šå¯¹ç±»çš„å±æ€§ç±»å‹è¿›è¡Œæ£€æŸ¥ã€‚å…¶ä¸­ç”± Clozure CLï¼ŒSBCL æ˜¯åœ¨2019å¹´11æœˆæ—¶å‘è¡Œçš„ 1.5.9 ç‰ˆæœ¬æ‰å¼€å§‹æ”¯æŒï¼Œæˆ–è€…æ˜¯è¿›è¡Œäº†é«˜å®‰å…¨æ€§çš„è®¾ç½®ï¼ˆ`(declaim (optimise safety))`ï¼‰

æƒ³è¦ä½¿ç”¨åˆ«çš„æ–¹æ³•çš„è¯ï¼Œå‚è€ƒ [this Stack-Overflow answer](https://stackoverflow.com/questions/51723992/how-to-force-slots-type-to-be-checked-during-make-instance) å’Œ [quid-pro-quo](https://github.com/sellout/quid-pro-quo) åº“

## find-class, class-name, class-of

~~~lisp
(find-class 'point)
;; #<STANDARD-CLASS POINT 275B78DC>

(class-name (find-class 'point))
;; POINT

(class-of my-point)
;; #<STANDARD-CLASS POINT 275B78DC>

(typep my-point (class-of my-point))
;; T
~~~

CLOS ä¸­çš„ç±»ä¹Ÿæ˜¯ CLOS ç±»çš„ä¸€ä¸ªå®ä¾‹ï¼Œå¦‚ä¸‹é¢ä»£ç æ‰€ç¤ºï¼š

~~~lisp
(class-of (class-of my-point))
;; #<STANDARD-CLASS STANDARD-CLASS 20306534>
~~~

<u>æ³¨</u>: è¿™æ˜¯ç¬¬ä¸€æ¬¡ä»‹ç» MOPï¼Œä¸å¿…è¿›è¡Œæ·±ç©¶

å¯¹è±¡ `my-point` æ˜¯ `point` ç±»çš„ä¸€ä¸ªå®ä¾‹ï¼Œè€Œ `point` ç±»åˆæ˜¯ `standard-class` çš„ä¸€ä¸ªå®ä¾‹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°† `standard-class` ç§°ä¸º `my-point` çš„ **å…ƒç±»(metaclass)** ï¼ˆå³ç±»çš„ç±»ï¼Œæœ‰ç‚¹ç»•ğŸ˜‚ï¼‰ã€‚ä¹‹åä¼šè®²åˆ°å¦‚ä½•ä½¿ç”¨å…ƒç±»ã€‚


## å­ç±»å’Œç»§æ‰¿

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ`child` æ˜¯ `person` çš„å­ç±»ã€‚

æ‰€æœ‰çš„å¯¹è±¡éƒ½ç»§æ‰¿è‡ª `standard-object` å’Œ `t` è¿™ä¸¤ä¸ªç±»ã€‚

æ‰€æœ‰ `child` çš„å®ä¾‹åŒæ—¶ä¹Ÿæ˜¯ `person` çš„å®ä¾‹ã€‚

~~~lisp
(type-of c1)
;; CHILD

(subtypep (type-of c1) 'person)
;; T

(ql:quickload "closer-mop")
;; ...

(closer-mop:subclassp (class-of c1) 'person)
;; T
~~~

[closer-mop](https://github.com/pcostanza/closer-mop) åº“ç”¨æ¥åš CLOS/MOP çš„ä¸€äº›æ“ä½œå¾ˆæ¹¿æ–¹ä¾¿ã€‚

å­ç±»ä¼šç»§æ‰¿çˆ¶ç±»æ‰€æœ‰çš„å±æ€§ï¼ŒåŒæ—¶ä¹Ÿèƒ½é‡å†™çˆ¶ç±»çš„å±æ€§ã€‚

ä»¥ä¸‹æ˜¯ `child` çš„ç»§æ‰¿å…³ç³»ï¼š

    child <- person <-- standard-object <- t

æ‰€ä»¥å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„ç»“æœï¼š

~~~lisp
(closer-mop:class-precedence-list (class-of c1))
;; (#<standard-class child>
;;  #<standard-class person>
;;  #<standard-class standard-object>
;;  #<sb-pcl::slot-class sb-pcl::slot-object>
;;  #<sb-pcl:system-class t>)
~~~

ä½†æ˜¯ï¼Œ`child` çš„ç›´æ¥çˆ¶ç±»åªèƒ½æ˜¯ `person`ï¼š

~~~lisp
(closer-mop:class-direct-superclasses (class-of c1))
;; (#<standard-class person>)
~~~

å¯ä»¥è°ƒç”¨ `class-direct-[subclasses, slots, default-initargs]` å’Œå…¶ä»–çš„å‡½æ•°æ¥å¯¹ç±»è¿›è¡Œä¸€äº›ç¡®è®¤ã€‚

ä»¥ä¸‹æ˜¯å±æ€§ç»§æ‰¿çš„è§„åˆ™ï¼š

- `:accessor` å’Œ `:reader`ï¼šç»§æ‰¿ï¼ŒåŒæ—¶ä¼šè¢«ç»„åˆèµ·æ¥ã€‚

- `:initarg`ï¼šåŒ `:accessor` å’Œ `:reader`ã€‚

- `:initform`ï¼š æœ€è¯¦ç»†çš„ï¼Œå°±æ˜¯è¯´ï¼Œå’Œ `class-precedence-list` ä¸€æ ·ã€‚

- `:allocation`ï¼šä¸ç»§æ‰¿ï¼Œé»˜è®¤ä¸ `:instance` ä¸€è‡´ã€‚


æœ€åä¸€ç‚¹ï¼Œåœ¨ä½¿ç”¨ç»§æ‰¿æ—¶è¦æ³¨æ„ç‚¹ï¼Œå› ä¸ºç»§æ‰¿ç¡®å®å¾ˆå®¹æ˜“è¢«è¯¯ç”¨ï¼Œè€Œå¤šç»§æ‰¿æœ‰å°†éš¾åº¦ä»¥å€æ•°å¢åŠ ã€‚æ‰€ä»¥ï¼Œå†™çš„æ—¶å€™æ³¨æ„ç‚¹ï¼Œç¡®å®šæ˜¯å¦æ˜¯ç¡®å®éœ€è¦ç»§æ‰¿ã€‚å»ºè®®æ˜¯å½“å±æ€§ç›¸åŒæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ç»§æ‰¿ï¼Œä½†æ˜¯å±æ€§ä¸åŒæ—¶ï¼Œæœ€å¥½è¿˜æ˜¯ä¸è¦ä½¿ç”¨ç»§æ‰¿ã€‚

## å¤šç»§æ‰¿

CLOS åŒæ—¶ä¹Ÿæ”¯æŒå¤šç»§æ‰¿ã€‚


~~~lisp
(defclass baby (child person)
  ())
~~~

çˆ¶ç±»åˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªç±»è¦æ˜¯æœ€åº•å±‚çš„é‚£ä¸ªç±»ï¼Œè€Œåä¸€æ¬¡é€’æ¨ï¼Œä¸”è¿™äº›ç±»éƒ½æ˜¯æå‰å®šä¹‰å¥½äº†çš„ã€‚


## é‡å®šä¹‰æˆ–ä¿®æ”¹ç±»

æœ¬èŠ‚å°†è®²è§£ä»¥ä¸‹ä¸¤ç‚¹ï¼š

- ç±»çš„é‡å®šä¹‰
- å°†å®ä¾‹æŒ‡å‘å…¶ä»–çš„ç±»


ç±»çš„é‡å®šä¹‰åªéœ€ä½¿ç”¨ `defclass` å®šä¹‰æˆæ–°çš„å°±å¥½äº†ï¼Œè€Œä¸”åªéœ€è¦ç¼–è¯‘ä»¥ä¸‹é‡å®šä¹‰çš„ç±»ï¼Œä¹‹å‰è¯¥ç±»çš„å®ä¾‹éƒ½ä¼šè¿›è¡Œç›¸å¯¹åº”çš„æ›´æ–°ï¼Œè¿™ç‚¹å°±å¾ˆé…·å§ã€‚

æ¯”å¦‚è¯´ï¼Œå°† `person` ç±»é‡å®šä¹‰ï¼š

~~~lisp
(defclass person ()
  ((name
    :initarg :name
    :accessor name)
   (lisper
    :initform nil
    :accessor lisper)))

(setf p1 (make-instance 'person :name "me" ))
~~~

ä¿®æ”¹ã€æ·»åŠ ã€åˆ é™¤ç­‰éƒ½å¯ä»¥è¿™æ ·æ“ä½œï¼š

~~~lisp
(lisper p1)
;; NIL

(defclass person ()
  ((name
    :initarg :name
    :accessor name)
   (lisper
    :initform t        ;; <-- from nil to t
    :accessor lisper)))

(lisper p1)
;; NIL (of course!)

(lisper (make-instance 'person :name "You"))
;; T

(defclass person ()
  ((name
    :initarg :name
    :accessor name)
   (lisper
    :initform nil
    :accessor lisper)
   (age
    :initarg :arg
    :initform 18
    :accessor age)))

(age p1)
;; => slot unbound error. This is different from "slot missing":

(slot-value p1 'bwarf)
;; => "the slot bwarf is missing from the object #<personâ€¦>"

(setf (age p1) 30)
(age p1) ;; => 30

(defclass person ()
  ((name
    :initarg :name
    :accessor name)))

(slot-value p1 'lisper) ;; => slot lisper is missing.
(lisper p1) ;; => there is no applicable method for the generic function lisper when called with arguments #(lisper).
~~~


`change-class` ç”¨æ¥ä¿®æ”¹ä¸€ä¸ªå®ä¾‹çš„ç±»ï¼š

~~~lisp
(change-class p1 'child)
;; we can also set slots of the new class:
(change-class p1 'child :can-walk-p nil)

(class-of p1)
;; #<STANDARD-CLASS CHILD>

(can-walk-p p1)
;; T
~~~

ä¸Šé¢ä¾‹å­ä¸­ï¼Œ`p1` ç”± `person` å˜æˆäº† `child`ï¼ŒåŒæ—¶ä¹Ÿç»§æ‰¿äº† `can-walk-p` çš„é»˜è®¤å±æ€§ã€‚

## ç¾åŒ–è¾“å‡º

æ¯æ¬¡åˆ›å»ºå¯¹è±¡æ—¶ï¼Œæ€»ä¼šå¾—åˆ°ä¸ªç±»ä¼¼ä¸‹é¢çš„è¾“å‡ºï¼š

    #<PERSON {1006234593}>

æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚

å¦‚æœæƒ³è¦çœ‹åˆ°æ›´å¤šçš„ä¿¡æ¯è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿæ¯”å¦‚è¯´æƒ³çœ‹åˆ°å¦‚ä¸‹çš„æ ¼å¼ï¼š

    #<PERSON me lisper: t>

å¯ä»¥é€šè¿‡å®šåˆ¶è¿™ä¸ªç±»çš„é€šç”¨æ–¹æ³• `print-object` å°±å¯ä»¥ç¾åŒ–è¾“å‡ºäº†ï¼š  

~~~lisp
(defmethod print-object ((obj person) stream)
      (print-unreadable-object (obj stream :type t)
        (with-accessors ((name name)
                         (lisper lisper))
            obj
          (format stream "~a, lisper: ~a" name lisper))))
~~~

è¿™å°†ä¼šå¾—åˆ°ä»¥ä¸‹è¾“å‡ºï¼š

~~~lisp
p1
;; #<PERSON me, lisper: T>
~~~

`print-unreadable-object` å°†æ‰“å° `#<...>`ï¼Œè¡¨æ˜ä¸èƒ½è®¿é—®è¯¥å¯¹è±¡å†…éƒ¨ã€‚å¯¹è±¡çš„ `:type t` å‚æ•°ä¼šè¦æ±‚æ‰“å°å¯¹è±¡ç±»å‹çš„å‰ç¼€ï¼Œä¹Ÿå°±æ˜¯è¯´ `PERSON`ã€‚å¦‚æœæ²¡æœ‰å‡½æ•°çš„è¯ï¼Œå°±ä¼šå¾—åˆ°`#<me, lisper: T>`ã€‚

å½“è®©ï¼Œå¯¹äºç®€å•çš„ç±»æ¥è¯´ï¼Œä½¿ç”¨ `with-accessors` å®å°±è¶³å¤Ÿäº†ã€‚

~~~lisp
(defmethod print-object ((obj person) stream)
  (print-unreadable-object (obj stream :type t)
    (format stream "~a, lisper: ~a" (name obj) (lisper obj))))
~~~

æ³¨ï¼šè®¿é—®æœªç»‘å®šé»˜è®¤å€¼çš„å±æ€§æ—¶ï¼Œä¼šæŠ¥é”™ã€‚å¯ä»¥ç”¨ `slot-boundp` å…ˆè¿›è¡Œç¡®è®¤ã€‚

å‚è€ƒä¸‹é¢çš„ä»£ç ï¼Œè¿™ä¸ªæ˜¯é»˜è®¤çš„è¾“å‡ºã€‚

~~~lisp
(defmethod print-object ((obj person) stream)
  (print-unreadable-object (obj stream :type t :identity t)))
~~~

è¿™é‡Œï¼Œ `:identity` è®¾ä¸º `t` æ—¶ä¼šæ‰“å° `{1006234593}` çš„åœ°å€ã€‚

## æ™®é€šç±»å‹çš„ç±»

ä¹Ÿæœ‰æ–¹æ³•å¯ä»¥ä¸ç”¨ CLOS æ¥åˆ›å»ºå¯¹è±¡ã€‚

é€šå¸¸æ¥è¯´ï¼Œä¸Šä¸€å°èŠ‚ä¸­æåˆ°çš„å‡½æ•°ä¹Ÿé€‚ç”¨äºé CLOS å®ä¾‹å¯¹è±¡ã€‚

~~~lisp
(find-class 'symbol)
;; #<BUILT-IN-CLASS SYMBOL>
(class-name *)
;; SYMBOL
(eq ** (class-of 'symbol))
;; T
(class-of ***)
;; #<STANDARD-CLASS BUILT-IN-CLASS>
~~~

ä»ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œ`symbol` å°±æ˜¯ç³»ç»Ÿç±»çš„å®ä¾‹ã€‚è¿™åªæ˜¯å¯¹åº”è¯­è¨€ä¸­ 75 ç§ç±»å‹ç›¸å¯¹åº”çš„çš„ç±»çš„å…¶ä¸­ä¸€ä¸ªç±»ã€‚è®¸å¤šç³»ç»Ÿç±»éƒ½ä¸ CLOS æœ¬èº«ç›¸å…³ã€‚ç„¶è€Œï¼Œä»¥ä¸‹ 33 ä¸­ç±»å‹è¿˜æ˜¯ä¼ ç»Ÿçš„ lisp ç±»å‹ï¼›

|`array`|`hash-table`|`readtable`|
|`bit-vector`|`integer`|`real`|
|`broadcast-stream`|`list`|`sequence`|
|`character`|`logical-pathname`|`stream`|
|`complex`|`null`|`string`|
|`concatenated-stream`|`number`|`string-stream`|
|`cons`|`package`|`symbol`|
|`echo-stream`|`pathname`|`synonym-stream`|
|`file-stream`|`random-state`|`t`|
|`float`|`ratio`|`two-way-stream`|
|`function`|`rational`|`vector`|

æ³¨æ„ï¼Œä»¥ä¸Šè¡¨æ ¼å¹¶ä¸åŒ…å«æ‰€æœ‰çš„ä¼ ç»Ÿ lisp ç±»å‹ï¼ˆæ¯”å¦‚è¯´ï¼š`atom`ã€`fixnum`ã€`short-float`ï¼‰

`t` è¿™ä¸ªç±»å‹å°±æ¯”è¾ƒæœ‰è¶£äº†ã€‚å› ä¸ºæ¯ä¸ª lisp å¯¹è±¡çš„ç±»å‹éƒ½æ˜¯ `t`ï¼ŒåŒæ—¶æ¯ä¸ª lisp å¯¹è±¡ä¹Ÿæ˜¯ `t` ç±»çš„å­ç±»ã€‚è¿™ä¸ªä¸ªåŒæ—¶å±äºå¤šä¸ªç±»çš„ç®€å•ç¤ºä¾‹ï¼Œå­˜åœ¨ **ç»§æ‰¿** ç›¸å…³é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜å°†åœ¨å°†åœ¨åé¢è¯¦ç»†è®¨è®ºã€‚

~~~lisp
(find-class t)
;; #<BUILT-IN-CLASS T 20305AEC>
~~~

é™¤äº†ä¸ lisp ç±»å‹å¯¹åº”çš„ç±»ä¹‹å¤–ï¼Œå®šä¹‰çš„æ¯ä¸ªç»“æ„ç±»å‹éƒ½æœ‰ä¸€ä¸ª CLOS ç±»ï¼š

~~~lisp
(defstruct foo)
FOO

(class-of (make-foo))
;; #<STRUCTURE-CLASS FOO 21DE8714>
~~~

`structure-object` çš„å…ƒç±»æ˜¯ `structure-class`ã€‚
æ— è®ºä¼ ç»Ÿ lisp å¯¹è±¡çš„å…ƒç±»æ˜¯ `standard-class`ã€`structure-class` è¿˜æ˜¯ `built-in-class`ï¼Œéƒ½ä¾èµ–äºå®ç°ã€‚
ä»¥ä¸‹æ˜¯å…¶ä½¿ç”¨é™åˆ¶ï¼š

|`built-in-class`| May not use `make-instance`, may not use `slot-value`, may not use `defclass` to modify, may not create subclasses.|
|`structure-class`| May not use `make-instance`, might work with `slot-value` (implementation-dependent). Use `defstruct` to subclass application structure types. Consequences of modifying an existing `structure-class` are undefined: full recompilation may be necessary.|
|`standard-class`|None of these restrictions.|


## è‡ªçœï¼ˆIntrospectionï¼‰

æˆ‘ä»¬å·²ç»è§è¿‡ä¸€äº›è‡ªçœçš„å‡½æ•°äº†ã€‚

æœ€å¥½æ˜¯å»æŸ¥çœ‹ [closer-mop](https://github.com/pcostanza/closer-mop) åº“ï¼ŒåŒæ—¶ä¹Ÿç»å¸¸å»çœ‹çœ‹ [CLOS & MOP specifications](https://clos-mop.hexstreamsoft.com/)ã€‚

æ›´å¤šè‡ªçœçš„å‡½æ•°:

```
closer-mop:class-default-initargs
closer-mop:class-direct-default-initargs
closer-mop:class-direct-slots
closer-mop:class-direct-subclasses
closer-mop:class-direct-superclasses
closer-mop:class-precedence-list
closer-mop:class-slots
closer-mop:classp
closer-mop:extract-lambda-list
closer-mop:extract-specializer-names
closer-mop:generic-function-argument-precedence-order
closer-mop:generic-function-declarations
closer-mop:generic-function-lambda-list
closer-mop:generic-function-method-class
closer-mop:generic-function-method-combination
closer-mop:generic-function-methods
closer-mop:generic-function-name
closer-mop:method-combination
closer-mop:method-function
closer-mop:method-generic-function
closer-mop:method-lambda-list
closer-mop:method-specializers
closer-mop:slot-definition
closer-mop:slot-definition-allocation
closer-mop:slot-definition-initargs
closer-mop:slot-definition-initform
closer-mop:slot-definition-initfunction
closer-mop:slot-definition-location
closer-mop:slot-definition-name
closer-mop:slot-definition-readers
closer-mop:slot-definition-type
closer-mop:slot-definition-writers
closer-mop:specializer-direct-generic-functions
closer-mop:specializer-direct-methods
closer-mop:standard-accessor-method
```


## æ›´å¤š

### defclass/std: ç¼–å†™çŸ­ç±»

[defclass/std](https://github.com/EuAndreh/defclass-std) åº“æä¾›äº†ä¸€ä¸ªæ¯” `defclass` æ ¼å¼æ›´ç®€çŸ­çš„å®ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šè‡ªåŠ¨æ·»åŠ  accessorï¼Œinitarg å¹¶å°† iniform è®¾ä¸º `nil`ï¼š
By default, it adds an accessor, an initarg and an initform to `nil` to your slots definition:


~~~lisp
(defclass/std example ()
  ((slot1 slot2 slot3)))
~~~

å®é™…å±•å¼€å°±æ˜¯è¿™æ ·çš„ï¼š

~~~lisp
(defclass example ()
  ((slot1
    :accessor slot1
    :initarg :slot1
    :initform nil)
   (slot2
     :accessor slot2
     :initarg :slot2
     :initform nil)
   (slot3
     :accessor slot3
     :initarg :slot3
     :initform nil)))
~~~

è¿™ä¸ªåº“èƒ½åšçš„æœ‰å¾ˆå¤šï¼Œä¹Ÿå¾ˆçµæ´»ï¼Œä½†æ˜¯ Common Lisp ç¤¾åŒºå‡ ä¹ä¸æ€ä¹ˆä½¿ç”¨ï¼šè‡ªè¡Œæ‰¿æ‹…é£é™©Â©ã€‚


# æ–¹æ³•

## åº

åœ¨æ¬¡å›å¿†ä¸‹æœ€å¼€å§‹å®šä¹‰çš„ `person` å’Œ `child` ç±»ï¼š

~~~lisp
(defclass person ()
  ((name
    :initarg :name
    :accessor name)))
;; => #<STANDARD-CLASS PERSON>

(defclass child (person)
  ())
;; #<STANDARD-CLASS CHILD>

(setf p1 (make-instance 'person :name "me"))
(setf c1 (make-instance 'child :name "Alice"))
~~~

ä¸‹é¢ï¼Œæˆ‘ä»¬å°†åˆ›å»ºæ–¹æ³•ï¼Œå®šåˆ¶æ–¹æ³•ï¼Œå¹¶ç»„åˆä½¿ç”¨æ–¹æ³•ï¼ˆbeforeï¼Œafterï¼Œaroundï¼‰å’Œä½¿ç”¨é™å®šè¯ã€‚

~~~lisp
(defmethod greet (obj)
  (format t "Are you a person ? You are a ~a.~&" (type-of obj)))
;; style-warning: Implicitly creating new generic function common-lisp-user::greet.
;; #<STANDARD-METHOD GREET (t) {1008EE4603}>

(greet :anything)
;; Are you a person ? You are a KEYWORD.
;; NIL
(greet p1)
;; Are you a person ? You are a PERSON.

(defgeneric greet (obj)
  (:documentation "say hello"))
;; STYLE-WARNING: redefining COMMON-LISP-USER::GREET in DEFGENERIC
;; #<STANDARD-GENERIC-FUNCTION GREET (2)>

(defmethod greet ((obj person))
  (format t "Hello ~a !~&" (name obj)))
;; #<STANDARD-METHOD GREET (PERSON) {1007C26743}>

(greet p1) ;; => "Hello me !"
(greet c1) ;; => "Hello Alice !"

(defmethod greet ((obj child))
  (format t "ur so cute~&"))
;; #<STANDARD-METHOD GREET (CHILD) {1008F3C1C3}>

(greet p1) ;; => "Hello me !"
(greet c1) ;; => "ur so cute"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Method combination: before, after, around.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod greet :before ((obj person))
  (format t "-- before person~&"))
#<STANDARD-METHOD GREET :BEFORE (PERSON) {100C94A013}>

(greet p1)
;; -- before person
;; Hello me

(defmethod greet :before ((obj child))
  (format t "-- before child~&"))
;; #<STANDARD-METHOD GREET :BEFORE (CHILD) {100AD32A43}>
(greet c1)
;; -- before child
;; -- before person
;; ur so cute

(defmethod greet :after ((obj person))
  (format t "-- after person~&"))
;; #<STANDARD-METHOD GREET :AFTER (PERSON) {100CA2E1A3}>
(greet p1)
;; -- before person
;; Hello me
;; -- after person

(defmethod greet :after ((obj child))
  (format t "-- after child~&"))
;; #<STANDARD-METHOD GREET :AFTER (CHILD) {10075B71F3}>
(greet c1)
;; -- before child
;; -- before person
;; ur so cute
;; -- after person
;; -- after child

(defmethod greet :around ((obj child))
  (format t "Hello my dear~&"))
;; #<STANDARD-METHOD GREET :AROUND (CHILD) {10076658E3}>
(greet c1) ;; Hello my dear


;; call-next-method

(defmethod greet :around ((obj child))
  (format t "Hello my dear~&")
  (when (next-method-p)
    (call-next-method)))
;; #<standard-method greet :around (child) {100AF76863}>

(greet c1)
;; Hello my dear
;; -- before child
;; -- before person
;; ur so cute
;; -- after person
;; -- after child

;;;;;;;;;;;;;;;;;
;; Adding in &key
;;;;;;;;;;;;;;;;;

;; In order to add "&key" to our generic method, we need to remove its definition first.
(fmakunbound 'greet)  ;; with Slime: C-c C-u (slime-undefine-function)
(defmethod greet ((obj person) &key talkative)
  (format t "Hello ~a~&" (name obj))
  (when talkative
    (format t "blah")))

(defgeneric greet (obj &key &allow-other-keys)
  (:documentation "say hi"))

(defmethod greet (obj &key &allow-other-keys)
  (format t "Are you a person ? You are a ~a.~&" (type-of obj)))

(defmethod greet ((obj person) &key talkative &allow-other-keys)
  (format t "Hello ~a !~&" (name obj))
  (when talkative
    (format t "blah")))

(greet p1 :talkative t) ;; ok
(greet p1 :foo t) ;; still ok


;;;;;;;;;;;;;;;;;;;;;;;

(defgeneric greet (obj)
  (:documentation "say hello")
  (:method (obj)
    (format t "Are you a person ? You are a ~a~&." (type-of obj)))
  (:method ((obj person))
    (format t "Hello ~a !~&" (name obj)))
  (:method ((obj child))
    (format t "ur so cute~&")))

;;;;;;;;;;;;;;;;
;;; Specializers
;;;;;;;;;;;;;;;;

(defgeneric feed (obj meal-type)
  (:method (obj meal-type)
    (declare (ignorable meal-type))
    (format t "eating~&")))

(defmethod feed (obj (meal-type (eql :dessert)))
    (declare (ignorable meal-type))
    (format t "mmh, dessert !~&"))

(feed c1 :dessert)
;; mmh, dessert !

(defmethod feed ((obj child) (meal-type (eql :soup)))
    (declare (ignorable meal-type))
    (format t "bwark~&"))

(feed p1 :soup)
;; eating
(feed c1 :soup)
;; bwark
~~~


## æ³›å‹å‡½æ•° (defgeneric, defmethod)

`æ³›å‹å‡½æ•°` æ˜¯ä¸€ä¸ª lisp å‡½æ•°ï¼Œå®ƒä¸ä¸€ç»„æ–¹æ³•ç›¸å…³è”ï¼Œå¹¶åœ¨è°ƒç”¨æ—¶åˆ†æ´¾å®ƒä»¬ã€‚æ‰€æœ‰å…·æœ‰ç›¸åŒå‡½æ•°åçš„æ–¹æ³•éƒ½å±äºç›¸åŒçš„æ³›å‹å‡½æ•°ã€‚

`defmethod` çš„æ ¼å¼ç±»ä¼¼äº `defun`ã€‚å°†ä»£ç ä½“ä¸å‡½æ•°åç›¸å…³è”ï¼Œä½†æ˜¯åªæœ‰å½“å‚æ•°çš„ç±»å‹ä¸ lambda åˆ—è¡¨å£°æ˜çš„æ¨¡å¼ç›¸åŒ¹é…æ—¶ï¼Œæ‰ä¼šæ‰§è¡Œè¯¥ä»£ç ä½“ã€‚

å‚æ•°ç±»å‹æœ‰å¯é€‰å‚æ•°ã€å…³é”®å­—å’Œ `&rest` å‚æ•°ã€‚

`defgeneric` å®šä¹‰äº†æ³›å‹å‡½æ•°ã€‚å½“å†™äº†ä¸€ä¸ª `defmethod` è€Œæ²¡æœ‰ç›¸åº”çš„ `defgeneric`ï¼Œä¸€ä¸ªæ³›å‹å‡½æ•°å°±ä¼šè‡ªåŠ¨åˆ›å»º(å‚è§ä¾‹å­)ã€‚

é€šå¸¸ï¼Œç¼–å†™ `defgeneric` æ˜¯ä¸ªå¥½ä¸»æ„ã€‚å¯ä»¥æ·»åŠ é»˜è®¤çš„å®ç°ï¼Œç”šè‡³ä¸€äº›æ–‡æ¡£ã€‚

~~~lisp
(defgeneric greet (obj)
  (:documentation "says hi")
  (:method (obj)
    (format t "Hi")))
~~~

æ–¹æ³•ä¸­çš„ lambda åˆ—è¡¨ä¸­éœ€è¦çš„å‚æ•°æœ‰ä»¥ä¸‹ä¸‰ç§å½¢å¼:

1- ç®€å•çš„å˜é‡:

~~~lisp
(defmethod greet (foo)
  ...)
~~~

ä¸Šé¢è¿™ç§æ–¹æ³•èƒ½æ¥å—ä»»ä½•å‚æ•°ï¼Œä¸”æ€»èƒ½é€‚ç”¨ã€‚

å˜é‡ `foo` é€šå¸¸ç»‘å®šåˆ°ç›¸åº”çš„å‚æ•°å€¼ã€‚

2- å˜é‡å’Œ**ç‰¹æ®Šç±»å‹**ï¼Œå¦‚ä¸‹:

~~~lisp
(defmethod greet ((foo person))
  ...)
~~~

åœ¨æœ¬ä¾‹ä¸­ï¼Œåªæœ‰å½“å˜é‡ `foo` æ˜¯ ç‰¹æ®Šç±»å‹çš„ç±» `person` *æˆ–å…¶å­ç±»*ï¼Œæ¯”å¦‚ `child`(å®é™…ä¸Šï¼Œ`child` ä¹Ÿæ˜¯ `person`)æ—¶ï¼Œæ‰ä¼šç»‘å®šåˆ°ç›¸åº”çš„å‚æ•°ã€‚

å¦‚æœä»»ä½•å‚æ•°ä¸èƒ½åŒ¹é…å…¶ç‰¹æ®Šç±»å‹ï¼Œé‚£ä¹ˆè¯¥æ–¹æ³•å°±ä¸*é€‚ç”¨*ï¼Œå¹¶ä¸”ä¸èƒ½ç”¨é‚£äº›å‚æ•°æ‰§è¡Œã€‚å°†å¾—åˆ°ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œå¦‚ â€œå½“ä½¿ç”¨å‚æ•°yyyè°ƒç”¨æ³›å‹å‡½æ•°xxxæ—¶ï¼Œæ²¡æœ‰é€‚ç”¨çš„æ–¹æ³•â€ã€‚

**åªæœ‰å¿…éœ€çš„å‚æ•°å¯ä»¥æŒ‡å®š**ã€‚ä¸èƒ½æŒ‡å®šå¯é€‰çš„ `&key` å‚æ•°ã€‚

3- å˜é‡å’Œ**eql specializer**

~~~lisp
(defmethod feed ((obj child) (meal-type (eql :soup)))
    (declare (ignorable meal-type))
    (format t "bwark~&"))

(feed c1 :soup)
;; "bwark"
~~~

eql specializer å¯ä»¥æ˜¯ä»»ä½•lispå½¢å¼ï¼Œè€Œä¸æ˜¯ç®€å•çš„ç¬¦å·(`:soup`)ã€‚å®ƒä¸ defmethod åŒä¸€æ—¶é—´æ‰§è¡Œã€‚

åªè¦ lambda åˆ—è¡¨çš„å½¢å¼ä¸æ³›å‹å‡½æ•°çš„å½¢å¼*å…¨ç­‰*ï¼Œå°±å¯ä»¥ä½¿ç”¨ç›¸åŒçš„å‡½æ•°åï¼Œä½†ä½¿ç”¨ä¸åŒçš„ specializer æ¥å®šä¹‰ä»»æ„æ•°é‡çš„æ–¹æ³•ã€‚ç³»ç»Ÿä¼šé€‰æ‹©æœ€*å…·ä½“*çš„é€‚ç”¨æ–¹æ³•å¹¶æ‰§è¡Œå…¶ä¸»ä½“ã€‚æœ€å…·ä½“çš„æ–¹æ³•æ˜¯å…¶ specializer æœ€æ¥è¿‘å‚æ•°çš„ `class-precedence-list` çš„å¤´éƒ¨çš„æ–¹æ³•(lambdaåˆ—è¡¨å·¦ä¾§çš„ç±»æ›´å…·ä½“)ã€‚specializers çš„æ–¹æ³•æ›´é€‚åˆæ²¡æœ‰ specializer çš„æ–¹æ³•ã€‚


**æ³¨æ„äº‹é¡¹ï¼š**

-   å®šä¹‰ä¸æ™®é€šå‡½æ•°åŒåçš„æ–¹æ³•ä¼šæŠ¥é”™ã€‚çœŸçš„æƒ³è¿™æ ·åšçš„è¯ï¼Œä½¿ç”¨é˜´å½±æœºåˆ¶ï¼ˆshadow mechanismï¼‰ã€‚

-   è¦å‘ç°æœ‰æ³›å‹æ–¹æ³•çš„ lambda åˆ—è¡¨æ·»åŠ æˆ–åˆ é™¤ `keys` æˆ– `rest` å‚æ•°ï¼Œå¯ä»¥ç”¨ `fmakunbound` (æˆ– `C-c C-u`(slime -undefine-function) å°†å…‰æ ‡æ”¾åœ¨ Slime ä¸­çš„å‡½æ•°ä¸Šåˆ é™¤å£°æ˜ï¼Œç„¶åé‡æ–°å¼€å§‹)ã€‚å¦åˆ™,ä½ ä¼šçœ‹åˆ°ï¼š

```
attempt to add the method
  #<STANDARD-METHOD NIL (#<STANDARD-CLASS CHILD>) {1009504233}>
to the generic function
  #<STANDARD-GENERIC-FUNCTION GREET (2)>;
but the method and generic function differ in whether they accept
&REST or &KEY arguments.
```

-   æ–¹æ³•å¯ä»¥é‡å®šä¹‰(å’Œæ™®é€šå‡½æ•°ä¸€æ ·).

-   å®šä¹‰æ–¹æ³•çš„é¡ºåºæ— å…³ç´§è¦ï¼Œä½†æ˜¯æ˜¯å®ƒä»¬çš„ specializer ç±»å¿…é¡»å·²ç»å®šä¹‰äº†ã€‚

-   éä¸“é—¨åŒ–å‚æ•°æˆ–å¤šæˆ–å°‘ç›¸å½“äºä¸“é—¨åŒ–ç±» `t`ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯æ‰€æœ‰çš„ä¸“é—¨åŒ–å‚æ•°éƒ½è¢«éšå¼åœ°è®¤ä¸ºæ˜¯â€œè¢«å¼•ç”¨çš„â€(åœ¨`å£°æ˜å¿½ç•¥`çš„æ„ä¹‰ä¸Š)ã€‚

-   æ¯ä¸ª `defmethod` ä¼šç”Ÿæˆï¼ˆå¹¶è¿”å›ï¼‰ä¸€ä¸ª CLOS ä¸­ `standard-method` çš„å®ä¾‹ã€‚

-   `eql` ä¸“é—¨åŒ–å™¨ä¸èƒ½åƒå¤„ç†å­—ç¬¦ä¸²é‚£æ ·å·¥ä½œã€‚å®é™…ä¸Šï¼Œå­—ç¬¦ä¸²æ˜¯é€šè¿‡ `equal` æˆ– `equalp` è¿›è¡Œæ¯”è¾ƒã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†å­—ç¬¦ä¸²èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ï¼Œå¹¶åœ¨ `eql` specializerå’Œå‡½æ•°è°ƒç”¨ä¸­ä½¿ç”¨è¯¥å˜é‡ã€‚

-   æ‰€æœ‰ç›¸åŒå‡½æ•°åçš„æ–¹æ³•éƒ½å±äºç›¸åŒçš„æ³›å‹å‡½æ•°ã€‚

-   æ‰€æœ‰ `defclass` ä¸­å®šä¹‰çš„ accessor å’Œ reader éƒ½æ˜¯æ–¹æ³•ã€‚å®ƒä»¬å¯ä»¥é‡å†™æˆ–è¢«ç›¸åŒæ³›å‹å‡½æ•°ä¸Šçš„å…¶ä»–æ–¹æ³•é‡å†™ã€‚


æ›´å¤šå‚è§ [defmethod on the CLHS](http://www.lispworks.com/documentation/lw70/CLHS/Body/m_defmet.htm).

## å¤šæ€

å¤šæ€æ˜¾å¼æ˜ç¡®çš„åˆ¶å®šäº†å¤šä¸ªæ³›å‹å‡½æ•°æ‰€éœ€çš„å‚æ•°ã€‚

è¿™äº›å‚æ•°ä¸å±äºç‰¹å®šçš„ç±»ã€‚è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬ä¸å¿…åƒåœ¨å…¶ä»–è¯­è¨€ä¸­é‚£æ ·ï¼Œå¿…é¡»å†³å®šè°ƒç”¨è¿™ä¸ªæ–¹æ³•çš„æœ€ä½³ç±»ã€‚

~~~lisp
(defgeneric hug (a b)
   (:documentation "Hug between two persons."))
;; #<STANDARD-GENERIC-FUNCTION HUG (0)>

(defmethod hug ((a person) (b person))
  :person-person-hug)

(defmethod hug ((a person) (b child))
  :person-child-hug)
~~~

æ›´å¤šå‚è§ [Practical Common Lisp](http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html#multimethods).

## æ§åˆ¶ setters (setf-ing methods)

åœ¨ Lisp ä¸­ï¼Œå¯ä»¥å®šä¹‰å‡½æ•°æˆ–æ–¹æ³•çš„ `setf` å‰¯æœ¬ã€‚ä¹Ÿè®¸ä½ æƒ³è¦è®©åœ¨å¦‚ä½•æ›´æ–°å¯¹è±¡ä¸Šæœ‰æ›´å¤šçš„æ§åˆ¶ã€‚

~~~lisp
(defmethod (setf name) (new-val (obj person))
  (if (equalp new-val "james bond")
    (format t "Dude that's not possible.~&")
    (setf (slot-value obj 'name) new-val)))

(setf (name p1) "james bond") ;; -> no rename
~~~

å¦‚æœä½ äº†è§£ Pythonçš„è¯ï¼Œè¿™ç§æ“ä½œä¸ `@property` è£…é¥°å™¨ä¸€æ ·ã€‚

## è°ƒåº¦æœºåˆ¶å’Œä¸‹ä¸ªæ–¹æ³•

å½“è°ƒç”¨æ³›å‹å‡½æ•°æ—¶ï¼Œåº”ç”¨ç¨‹åºä¸èƒ½ç›´æ¥è°ƒç”¨æ–¹æ³•ã€‚è°ƒåº¦æœºåˆ¶çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

1.  è®¡ç®—é€‚ç”¨æ–¹æ³•çš„åˆ—è¡¨
2.  å¦‚æœæ²¡æœ‰æ–¹æ³•å¯ç”¨ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸
3.  å°†é€‚ç”¨çš„æ–¹æ³•æŒ‰ç‰¹å¼‚æ€§æ’åº
4.  è°ƒç”¨æœ€ç‰¹å®šçš„æ–¹æ³•

`greet` æ³›å‹å‡½æ•°æœ‰ä¸‰ä¸ªå¯ä»¥æ–¹æ³•ï¼š

~~~lisp
(closer-mop:generic-function-methods #'greet)
(#<STANDARD-METHOD GREET (CHILD) {10098406A3}>
 #<STANDARD-METHOD GREET (PERSON) {1009008EC3}>
 #<STANDARD-METHOD GREET (T) {1008E6EBB3}>)
~~~

åœ¨æ–¹æ³•çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä»ç„¶å¯ä»¥é€šè¿‡*æœ¬åœ°å‡½æ•°* `call-next-method` è®¿é—®å…¶ä»–å¯ç”¨çš„æ–¹æ³•ã€‚æ­¤å‡½æ•°åœ¨æ–¹æ³•ä½“ä¸­å…·æœ‰è¯æ³•èŒƒå›´ï¼Œä½†èŒƒå›´ä¸ç¡®å®šã€‚è°ƒç”¨ä¸‹ä¸€ä¸ªæœ€ specific çš„æ–¹æ³•ï¼Œå¹¶è¿”å›è¯¥æ–¹æ³•è¿”å›çš„ä»»ä½•å€¼ã€‚`call-next-method` å¯ä»¥ç”¨ä»¥ä¸‹ä¸¤ç§æ–¹å¼è°ƒç”¨ï¼š

*   æ— å‚æ•°ï¼Œ*ä¸‹ä¸ªæ–¹æ³•* ä¹Ÿå°†æ¥æ”¶ä¸è¯¥æ–¹æ³•ç›¸åŒçš„å‚æ•°ï¼Œæˆ–æ˜¯

*   æ˜¾å¼å‚æ•°ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¦æ±‚é€‚ç”¨äºæ–°å‚æ•°çš„æ’åºé¡ºåºé›†å¿…é¡»ä¸ç¬¬ä¸€æ¬¡è°ƒç”¨æ³›å‹å‡½æ•°çš„å‚æ•°é¡ºåºç›¸åŒã€‚

ä¾‹å¦‚:

~~~lisp
(defmethod greet ((obj child))
  (format t "ur so cute~&")
  (when (next-method-p)
    (call-next-method)))
;; STYLE-WARNING: REDEFINING GREET (#<STANDARD-CLASS CHILD>) in DEFMETHOD
;; #<STANDARD-METHOD GREET (child) {1003D3DB43}>

(greet c1)
;; ur so cute
;; Hello Alice !
~~~

å½“æ²¡æœ‰ä¸‹ä¸€ä¸ªæ–¹æ³•æ—¶è°ƒç”¨ `call-next-method` ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚å¯ä»¥é€šè¿‡è°ƒç”¨æœ¬åœ°å‡½æ•° `next-method-p` (æœ‰è¯æ³•ä½œç”¨åŸŸå’Œä¸ç¡®å®šèŒƒå›´)æ¥ç¡®å®šä¸‹ä¸€ä¸ªæ–¹æ³•æ˜¯å¦å­˜åœ¨ã€‚

æœ€åæ³¨æ„ï¼Œæ¯ä¸ªæ–¹æ³•çš„ä¸»ä½“éƒ½å»ºç«‹äº†ä¸€ä¸ªä¸æ–¹æ³•çš„æ³›å‹å‡½æ•°åŒåçš„å—ã€‚å¦‚æœ `return-from` è¿™ä¸ªå‡½æ•°åï¼Œåˆ™é€€å‡ºå½“å‰æ–¹æ³•ï¼Œè€Œä¸æ˜¯å¯¹æ‰€åŒ…å«çš„æ³›å‹å‡½æ•°çš„è°ƒç”¨ã€‚

## æ–¹æ³•ä¿®é¥°ç¬¦(before, after, around)

åœ¨æœ¬ç« åºçš„ä¾‹å­ä¸­ï¼Œå·²ç»çŸ¥é“äº† `:before`ã€`:after` å’Œ `:around` ä¿®é¥°ç¬¦çš„ç”¨æ³•:

- `(defmethod foo :before (obj) (...))`
- `(defmethod foo :after (obj) (...))`
- `(defmethod foo :around (obj) (...))`

é»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨ CLOS æä¾›çš„*æ ‡å‡†æ–¹æ³•ç»„åˆ*æ¡†æ¶ä¸­ï¼Œåªèƒ½ä½¿ç”¨è¿™ä¸‰ä¸ªé™å®šç¬¦ä¸­çš„ä¸€ä¸ªï¼Œæ§åˆ¶æµç¨‹å¦‚ä¸‹:

- è°ƒç”¨**before-method** ä¼šåœ¨ä¸»æ–¹æ³•è°ƒç”¨å‰ã€‚å¦‚æœæœ‰å¾ˆå¤š before-methodï¼Œé‚£ä¹ˆå°±è°ƒç”¨**æ‰€æœ‰çš„**ã€‚ä»æœ€åä¸€ä¸ªå­ç±»å¼€å§‹ï¼Œç„¶åæ˜¯å…¶çˆ¶ç±»ï¼Œçˆ¶ç±»çš„çˆ¶ç±»(child before person)ã€‚
- è°ƒç”¨æœ€åº•å±‚çš„ä½¿ç”¨çš„ **primary method** ï¼Œåªè°ƒç”¨ä¸€ä¸ªæ–¹æ³•ã€‚
- è°ƒç”¨æ‰€æœ‰é€‚ç”¨çš„ **after-methods** ã€‚ è°ƒç”¨æ–¹æ³•æŒ‰ç»§æ‰¿é¡ºåºï¼Œæ˜¾ç¤ºå­ç±»ï¼Œç„¶åæ˜¯çˆ¶ç±»ï¼Œçˆ¶ç±»çš„çˆ¶ç±»â€¦â€¦

**æ³›å‹å‡½æ•°è¿”å›ä¸»æ–¹æ³•çš„å€¼**ã€‚å‰ç½®æ–¹æ³•å’Œåç½®æ–¹æ³•è¿”å›å€¼éƒ½ä¼šå¿½ç•¥ã€‚å…¶è¿”å›å€¼åªæ˜¯åœ¨å¯¹åº”çš„èŒƒå›´å†…æœ‰ç”¨ã€‚

ç„¶åæ˜¯ **around-methods**ã€‚è¿™å°±æ˜¯åˆšæ‰æè¿°çš„æ ¸å¿ƒæœºåˆ¶çš„åŒ…è£…å™¨ã€‚å¯¹äºæ•è·è¿”å›å€¼æˆ–å›´ç»•ä¸»æ–¹æ³•è®¾ç½®ç¯å¢ƒ(è®¾ç½®æ•è·ã€é”ã€æ‰§è¡Œè®¡æ—¶â€¦â€¦)éå¸¸æœ‰ç”¨ã€‚

å¦‚æœåˆ†æ´¾æœºåˆ¶æ‰¾åˆ° around æ–¹æ³•ï¼Œå®ƒå°†è°ƒç”¨è¯¥æ–¹æ³•å¹¶è¿”å›å…¶ç»“æœã€‚å¦‚æœ around æ–¹æ³•æœ‰ `call-next-method`ï¼Œå®ƒå°±ä¼šè°ƒç”¨ä¸‹ä¸€ä¸ªæœ€é€‚ç”¨çš„around-æ–¹æ³•ã€‚åªæœ‰å½“æˆ‘ä»¬åˆ°è¾¾ä¸»æ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬æ‰å¼€å§‹è°ƒç”¨å‰ç½®å’Œåç½®æ–¹æ³•ã€‚

å› æ­¤ï¼Œæ³›å‹å‡½æ•°çš„å®Œæ•´è°ƒåº¦æœºåˆ¶å¦‚ä¸‹æ‰€ç¤ºï¼š

1.  ç»Ÿè®¡å¯ç”¨çš„æ–¹æ³•ï¼Œæ ¹æ®å…¶ä¿®é¥°ç¬¦åˆ†åˆ«æ”¾ç½®åœ¨ä¸åŒçš„åˆ—è¡¨ä¸­
2.  æ²¡æœ‰æ‰¾åˆ°ä¸»æ–¹æ³•æ˜¯å°†ä¼šæŠ›å‡ºå¼‚å¸¸
3.  å°†æ¯ä¸ªæ–¹æ³•åˆ—è¡¨æŒ‰ç»§æ‰¿å…³ç³»æ’åº
4.  æ‰§è¡Œæœ€åº•å±‚çš„ `:around` æ–¹æ³•å¹¶è¿”å›è¯¥æ–¹æ³•çš„è¿”å›å€¼
5.  å½“ `:around` æ–¹æ³•è°ƒç”¨ `call-next-method`ï¼Œæ‰§è¡Œæ¬¡åº•å±‚ `:around` æ–¹æ³•;
6.  å¦‚æœä¸å­˜åœ¨ `:around` æ–¹æ³•ï¼Œæˆ–æ˜¯ `:around` æ–¹æ³•è°ƒç”¨ `call-next-method` æ—¶æ²¡æœ‰ä¸‹ä¸€ä¸ª `:around` æ–¹æ³•æ—¶ï¼Œå°†æŒ‰ç…§ä»¥ä¸‹çš„é¡ºåºæ‰§è¡Œï¼š

    a.  æŒ‰ç…§ç»§æ‰¿é¡ºåºä¾æ¬¡è°ƒç”¨æ‰€æœ‰çš„ `:before` æ–¹æ³•ï¼Œç›´åˆ°æ²¡æœ‰ `call-next-method` æˆ– `next-method-p`ï¼›

    b.  æ‰§è¡Œæœ€åº•å±‚çš„ä¸»æ–¹æ³•ï¼›

    c.  å½“ä¸»æ–¹æ³•æœ‰ `call-next-method`ï¼ŒæŒ‰ç…§ç»§æ‰¿é¡ºåºä¾æ¬¡è°ƒç”¨ï¼›

    d.  å½“ä¸»æ–¹æ³•è°ƒç”¨ `call-next-method`ï¼Œä½†æ˜¯æ²¡æœ‰ä¸‹ä¸€ä¸ªä¸»æ–¹æ³•æ—¶ï¼ŒæŠ›å‡ºå¼‚å¸¸;

    e.  æ‰§è¡Œå®Œä¸»æ–¹æ³•åï¼ŒæŒ‰ç…§ç»§æ‰¿é¡ºåºä¾æ¬¡è°ƒç”¨æ‰€æœ‰çš„ `:after` æ–¹æ³•ï¼Œç›´åˆ°æ²¡æœ‰ `call-next-method` æˆ– `next-method-p`ã€‚

å°†è¿™ä¸ªæµç¨‹çœ‹ä½œä¸€ä¸ªæ´‹è‘±ï¼Œæ‰€æœ‰çš„ `:around` æ–¹æ³•åœ¨æœ€å¤–å±‚ï¼Œ`:before` å’Œ `:after` æ–¹æ³•åœ¨ä¸­é—´å±‚ï¼Œä¸»æ–¹æ³•åœ¨å†…éƒ¨ã€‚

## å…¶ä»–æ–¹æ³•ç»„åˆ

åˆšæ‰çœ‹åˆ°çš„é»˜è®¤æ–¹æ³•ç»„åˆç±»å‹å« `standard`ï¼Œä½†ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–ç»„åˆæ–¹æ³•ï¼Œä¸ç”¨ç”¨å¤šè¯´ï¼Œä½ å¯ä»¥å®šä¹‰è‡ªå·±çš„æ–¹æ³•ç»„åˆç±»å‹ã€‚

å†…å»ºçš„ç±»å‹æœ‰:

    progn + list nconc and max or append min

æ³¨æ„åˆ°è¿™äº›ç±»å‹æ˜¯ä»¥ lisp æ“ä½œç¬¦å‘½åçš„ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬æ‰€åšçš„æ˜¯å®šä¹‰ä¸€ä¸ªæ¡†æ¶ï¼Œè¯¥æ¡†æ¶å°†é€‚ç”¨çš„ä¸»è¦æ–¹æ³•ç»„åˆåœ¨å¯¹è¯¥åç§°çš„ lisp æ“ä½œç¬¦çš„è°ƒç”¨ä¸­ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ `progn` ç»„åˆç±»å‹ç›¸å½“äºé€ä¸ªè°ƒç”¨**æ‰€æœ‰**çš„ä¸»è¦æ–¹æ³•:

~~~lisp
(progn
  (method-1 args)
  (method-2 args)
  (method-3 args))
~~~

è¿™é‡Œï¼Œä¸æ ‡å‡†æœºåˆ¶ä¸åŒï¼Œè°ƒç”¨æ‰€æœ‰é€‚ç”¨äºç»™å®šå¯¹è±¡çš„ä¸»è¦æ–¹æ³•æ—¶ï¼Œé¦–å…ˆè°ƒç”¨æœ€è¯¦ç»†çš„æ–¹æ³•ã€‚

ä¸ºäº†æ”¹å˜ç»„åˆç±»å‹ï¼Œè®¾ç½®äº† `defgeneric` çš„ `:method-combination` é€‰é¡¹ï¼Œå¹¶å°†å…¶ç”¨ä½œæ–¹æ³•çš„é™å®šç¬¦:

~~~lisp
(defgeneric foo (obj)
  (:method-combination progn))

(defmethod foo progn ((obj obj))
   (...))
~~~

ä»¥ä¸‹æ˜¯ **progn** çš„ä¾‹å­:

~~~lisp
(defgeneric dishes (obj)
   (:method-combination progn)
   (:method progn (obj)
     (format t "- clean and dry.~&"))
   (:method progn ((obj person))
     (format t "- bring a person's dishes~&"))
   (:method progn ((obj child))
     (format t "- bring the baby dishes~&")))
;; #<STANDARD-GENERIC-FUNCTION DISHES (3)>

(dishes c1)
;; - bring the baby dishes
;; - bring a person's dishes
;; - clean and dry.

(greet c1)
;; ur so cute  --> only the most applicable method was called.
~~~

ç±»ä¼¼åœ°ï¼Œä½¿ç”¨ `list` ç±»å‹ç›¸å½“äºè¿”å›æ–¹æ³•å€¼çš„åˆ—è¡¨ã€‚

~~~lisp
(list
  (method-1 args)
  (method-2 args)
  (method-3 args))
~~~

~~~lisp
(defgeneric tidy (obj)
  (:method-combination list)
  (:method list (obj)
    :foo)
  (:method list ((obj person))
    :books)
  (:method list ((obj child))
    :toys))
;; #<STANDARD-GENERIC-FUNCTION TIDY (3)>

(tidy c1)
;; (:toys :books :foo)
~~~

**Around æ–¹æ³•** æ˜¯å¯ä»¥ä½¿ç”¨çš„:

~~~lisp
(defmethod tidy :around (obj)
   (let ((res (call-next-method)))
     (format t "I'm going to clean up ~a~&" res)
     (when (> (length res)
              1)
       (format t "that's too much !~&"))))

(tidy c1)
;; I'm going to clean up (toys book foo)
;; that's too much !
~~~

æ³¨æ„ï¼Œè¿™äº›æ“ä½œç¬¦ä¸æ”¯æŒ `before`ã€`after` å’Œ `around` æ–¹æ³•(å®é™…ä¸Šï¼Œå®ƒä»¬å·²ç»æ²¡æœ‰ç©ºé—´äº†)ã€‚å®ƒä»¬ç¡®å®æ”¯æŒ `around` æ–¹æ³•ï¼Œå…¶ä¸­ä¹Ÿå¯ä»¥è°ƒç”¨ `call-next-method` ï¼Œä½†æ˜¯ä¸æ”¯æŒåœ¨ä¸»æ–¹æ³•ä¸­è°ƒç”¨ `call-next-method`(è¿™ç¡®å®æ˜¯å¤šä½™çš„ï¼Œå› ä¸ºæ‰€æœ‰çš„ä¸»æ–¹æ³•éƒ½è¢«è°ƒç”¨äº†ï¼Œå´ç¬¨æ‹™åœ°**ä¸**è°ƒç”¨ä¸€ä¸ªä¸»æ–¹æ³•)ã€‚

CLOS å…è®¸å°†æ–°çš„æ“ä½œç¬¦å®šä¹‰ä¸ºæ–¹æ³•ç»„åˆç±»å‹ï¼Œæ— è®ºæ˜¯ lisp å‡½æ•°ã€å®è¿˜æ˜¯ç‰¹æ®Šå½¢å¼ã€‚éœ€è¦æ˜¯å¯ä»¥æŸ¥è¯¢æ–‡ä¸­æ‰€æåˆ°çš„ä¸€äº›ä¹¦ç±é“¾æ¥ã€‚

## Debugging: è·Ÿè¸ªæ–¹æ³•ç»„åˆ

å¯ä»¥[è·Ÿè¸ª](http://www.xach.com/clhs?q=trace)æ–¹æ³•ç»„åˆï¼Œä½†è¿™å–å†³äºå®ç°ã€‚

åœ¨ SBCL ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `(trace foo :methods t)`ã€‚è¯¦æƒ…å‚è§ [this post by an SBCL core developer](http://christophe.rhodes.io/notes/blog/posts/2018/sbcl_method_tracing/).

ä¸‹é¢æ˜¯ä¸ªé€šç”¨çš„ä¾‹å­ï¼š

~~~lisp
(defgeneric foo (x)
  (:method (x) 3))
(defmethod foo :around ((x fixnum))
  (1+ (call-next-method)))
(defmethod foo ((x integer))
  (* 2 (call-next-method)))
(defmethod foo ((x float))
  (* 3 (call-next-method)))
(defmethod foo :before ((x single-float))
  'single)
(defmethod foo :after ((x double-float))
 'double)
~~~

è¿½è¸ªä»¥ä¸‹ï¼š

~~~lisp
(trace foo :methods t)

(foo 2.0d0)
  0: (FOO 2.0d0)
    1: ((SB-PCL::COMBINED-METHOD FOO) 2.0d0)
      2: ((METHOD FOO (FLOAT)) 2.0d0)
        3: ((METHOD FOO (T)) 2.0d0)
        3: (METHOD FOO (T)) returned 3
      2: (METHOD FOO (FLOAT)) returned 9
      2: ((METHOD FOO :AFTER (DOUBLE-FLOAT)) 2.0d0)
      2: (METHOD FOO :AFTER (DOUBLE-FLOAT)) returned DOUBLE
    1: (SB-PCL::COMBINED-METHOD FOO) returned 9
  0: FOO returned 9
9
~~~


# MOP

è¿™é‡Œæ”¶é›†äº†ä¸€äº›ä½¿ç”¨å…ƒå¯¹è±¡åè®®æä¾›çš„æ¡†æ¶çš„ä¾‹å­ï¼Œè¿™ä¸ªå¯é…ç½®çš„å¯¹è±¡ç³»ç»Ÿå†³å®šäº† Lisp å¯¹è±¡ç³»ç»Ÿã€‚æœ¬èŠ‚æ¶‰åŠåˆ°äº†é«˜çº§æ¦‚å¿µï¼Œæ‰€ä»¥ï¼Œåˆšå¼€å§‹å­¦ä¹ çš„è¯ï¼Œä¸è¦æ‹…å¿ƒï¼šä½ å¿…ç†è§£æœ¬èŠ‚å†…å®¹å°±å¯ä»¥ä½¿ç”¨ Common Lisp  å¯¹è±¡ç³»ç»Ÿã€‚

è¿™é‡Œä¸ä¼šè¿‡å¤šåœ°è®²è§£ MOPï¼Œä½†å¸Œæœ›èƒ½å¤Ÿå……åˆ†å±•ç¤ºçœ‹åˆ°å®ƒçš„å¯èƒ½æ€§ï¼Œæˆ–è€…å¸®åŠ©ç†è§£ä¸€äº›CLåº“æ˜¯å¦‚ä½•æ„å»ºçš„ã€‚æ„Ÿå…´è¶£çš„è¯å¯ä»¥çœ‹çœ‹ä»‹ç»ä¸­æåˆ°çš„ä¹¦ã€‚

## å…ƒç±»

å…ƒç±»æ˜¯ç”¨æ¥æ§åˆ¶å…¶ä»–ç±»çš„ä¸€äº›è¡Œä¸ºæ“ä½œçš„ã€‚

*As announced, we won't talk much. See also Wikipedia for [metaclasses](https://en.wikipedia.org/wiki/Metaclass) or [CLOS](https://en.wikipedia.org/wiki/Common_Lisp_Object_System)*.

æ ‡å‡†çš„å…ƒç±»æ˜¯ `standard-class`:

~~~lisp
(class-of p1) ;; #<STANDARD-CLASS PERSON>
~~~

ä½†å¯ä»¥å°† `standard-class` ä¿®æ”¹æˆè‡ªå·±çš„å…ƒç±»ã€‚è¿™æ ·å°±å¯ä»¥ **è®¡ç®—å®ä¾‹åˆ›å»ºçš„ä¸ªæ•°** äº†ã€‚åŒæ ·çš„æœºåˆ¶å¯ä»¥è¿ç”¨åœ¨æ•°æ®åº“çš„ä¸»é”®çš„è‡ªåŠ¨å¢åŠ ä¸Šï¼Œç”¨æ¥è®°å½•åˆ›å»ºå¯¹è±¡ç­‰ã€‚

è¯¥å…ƒç±»ç»§æ‰¿è‡ª `standard-class`:

~~~lisp
(defclass counted-class (standard-class)
  ((counter :initform 0)))
#<STANDARD-CLASS COUNTED-CLASS>

(unintern 'person)
;; this is necessary to change the metaclass of person.
;; or (setf (find-class 'person) nil)
;; https://stackoverflow.com/questions/38811931/how-to-change-classs-metaclass#38812140

(defclass person ()
  ((name
    :initarg :name
    :accessor name))
  (:metaclass counted-class)) ;; <- metaclass
;; #<COUNTED-CLASS PERSON>
;;   ^^^ not standard-class anymore.
~~~

`:metaclass` é€‰é¡¹åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚

äº‹å®ä¸Šï¼Œåº”è¯¥å¾—åˆ°ä¸€ä¸ªå®ç° `validate-superclass` çš„æ¶ˆæ¯ã€‚åŒæ ·çš„ï¼Œè°ƒç”¨ `closer-mop` åº“ï¼š

~~~lisp
(defmethod closer-mop:validate-superclass ((class counted-class)
                                           (superclass standard-class))
  t)
~~~

ç°åœ¨å°±å¯ä»¥æ§åˆ¶åˆ›å»º `person` ç±»çš„å®ä¾‹äº†ã€‚

~~~lisp
(defmethod make-instance :after ((class counted-class) &key)
  (incf (slot-value class 'counter)))
;; #<STANDARD-METHOD MAKE-INSTANCE :AFTER (COUNTED-CLASS) {1007718473}>
~~~

`:after` å…³é”®è¯æ˜¯ä¸ªå¾ˆå¥½çš„é€‰æ‹©ï¼Œè¿™æ ·å¯ä»¥è®©æ ‡æ³¨çš„æ–¹æ³•æ­£å¸¸è¿è¡Œï¼Œç„¶åè¿”å›ä¸€ä¸ªæ–°çš„å®ä¾‹


`&key` æ˜¯å¿…é¡»çš„ï¼Œ æ³¨æ„ï¼Œè¿™ä¸ªæ˜¯ç”¨æ¥æ¥æ”¶ `make-instance` çš„ `initargs` çš„.

ç°åœ¨å†è¯•è¯•çœ‹:

~~~lisp
(defvar p3 (make-instance 'person :name "adam"))
#<PERSON {1007A8F5B3}>

(slot-value p3 'counter)
;; => error. No, our new slot isn't on the person class.
(slot-value (find-class 'person) 'counter)
;; 1

(make-instance 'person :name "eve")
;; #<PERSON {1007AD5773}>
(slot-value (find-class 'person) 'counter)
;; 2
~~~

è¿™æ ·å°±æ­£å¸¸äº†ã€‚


## æ§åˆ¶å®ä¾‹çš„åˆå§‹å€¼ (initialize-instance)

ä¸ºäº†è¿›ä¸€æ­¥æ§åˆ¶åˆ›å»ºå¯¹è±¡å®ä¾‹ï¼Œå¯ä»¥åˆ¶å®šä¸€äº› `initialize-instance` æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¼šåœ¨ å®ä¾‹åˆ›å»ºåä½†è¿˜æ²¡æœ‰å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–æ—¶è¢«`make-instance` æ‰€è°ƒç”¨ï¼Œ

Keene å»ºè®®åˆ›å»º `after` æ–¹æ³•ï¼Œå› ä¸ºåˆ›å»ºä¸»æ–¹æ³•å°†é˜»æ­¢å±æ€§åˆå§‹åŒ–ã€‚

~~~lisp
(defmethod initialize-instance :after ((obj person) &key) ;; note &key
  (do something with obj))
~~~

ä¸‹é¢çš„ä¾‹å­å¯ä»¥å¯¹åˆå§‹å€¼è¿›è¡ŒéªŒè¯ã€‚è¯¥ä»£ç ä¼šç¡®ä¿ `person` çš„ `name` é•¿åº¦ä¸å°‘äº 3 ä¸ªå­—ç¬¦ã€‚

~~~lisp
(defmethod initialize-instance :after ((obj person) &key)
  (with-slots (name) obj
    (assert (>= (length name) 3))))
~~~

æ‰€ä»¥ï¼Œä»¥ä¸‹çš„ä»£ç è¿è¡Œä¼šå‡ºé”™ï¼š

~~~lisp
(make-instance 'person :name "me" )
;; The assertion (>= #1=(LENGTH NAME) 3) failed with #1# = 2.
;;   [Condition of type SIMPLE-ERROR]
~~~

å› æ­¤ï¼Œå¯ä»¥ç»™ debugger åŠ ä¸ª "name" çš„ç‰¹æ€§ï¼š

~~~lisp
(defmethod INITIALIZE-INSTANCE :after ((obj person) &key)
  (with-slots (name) obj
    (assert (>= (length name) 3)
            (name)  ;; creates a restart that offers to change "name"
            "The value of name is ~a. It should be longer than 3 characters." name)))
~~~

ä¸Šé¢çš„ä»£ç å°†ä¼šå¾—åˆ°ä»¥ä¸‹çš„è¾“å‡ºï¼š

```
The value of name is me. It should be longer than 3 characters.
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [CONTINUE] Retry assertion with new value for NAME.    <--- new restart
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
```

å¦ä¸€ä¸ªæ¯”è¾ƒåˆç†çš„æ˜¯ï¼Œ CLOS ä¸­ `make-instance` å®ç°çš„ä¸¤ä¸ªé˜¶æ®µï¼šç”³è¯·æ–°çš„å¯¹è±¡ï¼Œç„¶åå°†è¿™ä¸ªå¯¹è±¡å’Œå‚æ•°ä¼ ç»™é€šç”¨å‡½æ•° `initialize-instance `ã€‚è§£é‡Šå™¨å’Œç¨‹åºå‘˜é€šè¿‡å®šä¹‰ `initialize-instance` çš„ `:after` æ–¹æ³•ï¼Œæ¥å¯¹å®ä¾‹çš„å±æ€§å€¼è¿›è¡Œåˆå§‹åŒ–ã€‚ç³»ç»Ÿæä¾›çš„ä¸»è¦æ–¹æ³•ä¼šå°† (a) `:initform` å’Œ `:initarg` å®šä¹‰çš„å€¼ å’Œ (b) é€šè¿‡ `makt-instance` çš„å…³é”®è¯ä¼ é€’è¿›æ¥çš„å‚æ•°ç»‘å®šåœ¨ä¸€èµ·ã€‚å¯ä»¥ä½¿ç”¨å…¶ä»–çš„æ–¹æ³•æ¥è¿›è¡Œæ‹“å±•ã€‚æ¯”å¦‚è¯´ï¼Œå¯ä»¥é€šè¿‡è®¿é—®æ•°æ®åº“å¯¹ç‰¹å®šçš„å±æ€§è¿›è¡Œå¡«å……ã€‚ `initialize-instance` çš„ lambda åˆ—è¡¨ä¸ºï¼š 

~~~
initialize-instance instance &rest initargs &key &allow-other-keys
~~~

æ›´å¤šçš„ç›¸å…³çš„çŸ¥è¯†ï¼Œå»çœ‹çœ‹æœ¬ç« æ¨èçš„ä¹¦å§ !
